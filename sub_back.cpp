#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include <string>
using namespace cv;
using namespace std;
// Global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask fg mask generated by MOG2 method
Mat bgMask;
Mat fgFrame;
Mat bgFrame;
Mat finalMat;
Ptr<BackgroundSubtractor> pMOG; //MOG2 Background subtractor
int keyboard; //input from keyboard
void help();
void processVideo();

std::string type2string(cv::Mat mat)
{
	std::string r;
	switch (mat.depth()) {
	case CV_8U:
		r = "8U"; 
		break;
	case CV_8S:  
		r = "8S"; 
		break;
	case CV_16U: 
		r = "16U"; 
		break;
	case CV_16S: 
		r = "16S"; 
		break;
	case CV_32S: 
		r = "32S"; 
		break;
	case CV_32F: 
		r = "32F"; 
		break;
	case CV_64F: 
		r = "64F"; 
		break;
	default:
		r = "User"; 
		break;
  }
	r = r + "C" + std::to_string(mat.channels());
	return r;
}

int main(int argc, char* argv[])
{
    //print help information

    // namedWindow("FG Mask MOG 2");
    //create Background Subtractor objects
    pMOG = createBackgroundSubtractorMOG2(); //MOG2 approach
    processVideo();
    destroyAllWindows();
    return EXIT_SUCCESS;
}
void processVideo() {
    //create the capture object
    VideoCapture capture("video.mp4");
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open camera: " << endl;
        exit(EXIT_FAILURE);
    }
    bool pause = false;
    //read input data. ESC or 'q' for quitting
    while(1){
        //read the current frame
	if (!pause) {
		cout << "here" << endl;
		if(!capture.read(frame)) {
		    cerr << "Unable to read next frame." << endl;
		    cerr << "Exiting..." << endl;
		    exit(EXIT_FAILURE);
		}
		//update the background model
		Mat win_mat(cv::Size(frame.cols * 2, frame.rows * 2), CV_8UC3);
		pMOG->apply(frame, fgMaskMOG, -1);
		pMOG->getBackgroundImage(bgFrame);

		/* floodfill the mask for better results*/
		Mat element = getStructuringElement(MORPH_RECT, Size(3, 3), Point(-1, -1));
		cv::dilate(fgMaskMOG, fgMaskMOG, element, Point(-1, -1), 1);
		for (int i = 0; i < bgMask.rows; i++)
			for (int j = 0; j < bgMask.cols; ++j)
				if (fgMaskMOG.at<uchar>(i, j) > 0)
					fgMaskMOG.at<uchar>(i, j) = 255;
		cv::Mat floodFill = fgMaskMOG.clone();
		cv::floodFill(floodFill, cv::Point(0,0), cv::Scalar(255));
		bitwise_not(floodFill, floodFill);
		floodFill = fgMaskMOG | floodFill;
		fgMaskMOG = floodFill;

		/* get background mask */
		cv::bitwise_not(fgMaskMOG, bgMask);

		cv::cvtColor(bgMask, bgMask, CV_GRAY2BGR);
		cv::cvtColor(fgMaskMOG, fgMaskMOG, CV_GRAY2BGR);
		
		/* mask original frame
		 * fill holes in the frame by masking the background
		 */
		cv::bitwise_and(bgMask, frame, fgFrame);
		cv::bitwise_and(bgFrame, fgMaskMOG, bgFrame);
		cv::bitwise_or(fgFrame, bgFrame, finalMat);

		frame.copyTo(win_mat(Rect(0, 0, frame.cols, frame.rows)));
		bgFrame.copyTo(win_mat(Rect(frame.cols, 0, frame.cols, frame.rows)));
		fgFrame.copyTo(win_mat(Rect(0, frame.rows, frame.cols, frame.rows)));
		finalMat.copyTo(win_mat(Rect(frame.cols, frame.rows, frame.cols, frame.rows)));
	//	imshow("frame", frame);
	//	imshow("bgframe", bgFrame);
	//	imshow("fgframe", fgFrame);
	//	imshow("final frame", finalMat);
		imshow("project", win_mat);
	    }
	char key = waitKey(30);
	if (key == 'p')
		pause = !pause;
	else if (key == 's')
		break;
    }
    //delete capture object
    capture.release();
}
